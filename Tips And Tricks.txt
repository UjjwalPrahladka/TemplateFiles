
greedy ?

dp ? constraints too much ? upperbound on constraint is less?

brute force ? not many iterations required ? root(n) split ? 1 precal 2 solve

binary search ? 

edge cases ? 0 ? 1 ? negative?

find the least number? how about iterate on bits? choose 0 whenever possible?
build trie to simulate?

dp try to reduce number of states. Maybe some states are dependent on the other?

for string instead of storing position as state where dp value stores boolean value maybe store in dp minimal position 
in string to satisfy the state. That way you get rid of 1 state ie pos
Use next occurances of characters to make transitions.

string problem ? precalc next[i][j] = index of character j after i and make jumps

permutation? try brute force for 1 then see how the answer changes for 2, 3... so on.

number of arrays of size n with sum atmost x? Checkout CF #788 F. 

working on bits? consider 60th bit as 0th one so its value will be 1 for now so every bit you turn on will contribute 1. When moving to 59 multiply info by 2.


question similar to RBS ? ( => 1, ) => -1, sum is 0 and minimum value in perf sum is 0.
checking for RBS? cnt( >= cnt) for all pref AND cnt) >= cnt( for all suf
cyclic shifts are possible as it starts with 0 and ends at 0.


FUN FACT : Grey code minimizes sum of xor of consecutive integers. Works for 0 .. 2 ^ n - 1


Partitioning in two parts ? Bipartite Graph ? Euler Circuits?. See CF# 770 E